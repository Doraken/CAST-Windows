#------------------------------------------------------------------------
# Source File Information (DO NOT MODIFY)
# Source ID: e3672151-b950-4412-abac-3706eeb19c7f
# Source File: D:\arnau\Documents\GitHub\CAST-Windows\Quick-scripts\Quick-scripts.psproj
#------------------------------------------------------------------------
<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.150
     Generated on:       12/04/2018 14:35
     Generated by:       arnau
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2018
#>



#region Source: Startup.pss
#----------------------------------------------
#region Import Assemblies
#----------------------------------------------
[void][Reflection.Assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
[void][Reflection.Assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
#endregion Import Assemblies

#Define a Param block to use custom parameters in the project
#Param ($CustomParameter)

function Main {
<#
    .SYNOPSIS
        The Main function starts the project application.
    
    .PARAMETER Commandline
        $Commandline contains the complete argument string passed to the script packager executable.
    
    .NOTES
        Use this function to initialize your script and to call GUI forms.
		
    .NOTES
        To get the console output in the Packager (Forms Engine) use:
		$ConsoleOutput (Type: System.Collections.ArrayList)
#>
	Param ([String]$Commandline)
	
	#--------------------------------------------------------------------------
	#TODO: Add initialization script here (Load modules and check requirements)
	
	Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('TODO: Add script to the Main function of Startup.pss', 'TODO') 
	
	#--------------------------------------------------------------------------
	
	
	
	$script:ExitCode = 0 #Set the exit code for the Packager
}




#endregion Source: Startup.pss

#region Source: Gen-Password.ps1
function Invoke-Gen-Password_ps1
{
	#Create-GroupAndAccountForsSharepoint.ps1 Version 1.0
	#Writen by Arnaud crampet 
	# 
	$DebugLevel             = 0
	$StackFunct             = $MyInvocation.MyCommand.name.split('\.')[-2]       #Initialisation de la variable de stacktrace.
	#Variable de gestion du temps
	$timestamp              = Get-Date -UFormat "%Y-%m-%d_%H-%M"       # Horodatage pour les log fichiers
	$Global:timestampFile   = Get-Date -UFormat "%Y-%m-%d_%H-%M"       # Horodatage pour les Noms fichiers
	
	# Variable de gestion des nom de fichier de log et ou de traces.
	$GLBFolderLogs         = "."
	$BaseLogFile            = $GLBFolderLogs + "\Execution_log"   + $timestamp + ".txt"      #|#_LogFile   # Log generique d'exécution.
	$BaseLogErr             = $GLBFolderLogs + "\Error_log"       + $timestamp + ".txt"      #|#_LogFile   # Log d'erreur.
	$BaseLogAccnt           = $GLBFolderLogs + "\Account_log"     + $timestamp + ".txt"      #|#_LogFile   # Log de création des comptes.
	
	
	
	# Fonction extraite du FrameWork CAST-W ( Common application Scripting Framwork - Windows ecrit par Arnaud Crampet 
	
	
	
	function WorkDateInFIle () 
	{
	    # Auteur : Arnaud Crampet 19/12/2014
	    # Fonction        : de génération variable de date pour l'hotrodatage des fichiers de logs. 
	    # paramètres      : Aucun paramètres 
	    # Utilisation     : WorkDateInFIle
	    # Varable utilisé : 
	    
	    
	    $Global:timestamp = Get-Date -UFormat "%Y-%m-%d;%H:%M"
	 
	   
	}
	
	function WorkDateFileName () 
	{
	    # Auteur : Arnaud Crampet 19/12/2014
	    # Fonction de génération de stack d'execution des fonctions 
	    # $_FunctName        = Nom de la fontion à ajouter ou à supprimer.
	    # Utilisation : WorkDate
	    
	
	    $Global:timestampFile = Get-Date -UFormat "%Y-%m-%d_%H-%M"
	
	   
	}
	
	
	function Write-GlbLogAndMessages ( [string]$_UsedLine, [int]$_errlevel, [boolean]$_Isfatal ) 
	{
	    #Gestion des erreur avec debord en log. 
	    # $_UsedLine = contient la ligne de log à afficher / ecrire dans les log 
	    # $_errlevel = indique le niveau de débug
	    # $_Isfatal  =  indique si l'erreur doit provoquer la sortie.
	    # Utilisation : Write-GlbLogAndMessages ("Texte de l'information") ("Niveau de l'erreur") ("Est fatale ou non") 
	
	    # Récupération de l'horodatage.
	    WorkDateInFIle
	
	    if ($_Isfatal -eq $True ) 
	        {
	            # Emmission de la log texte vers le fichier d'erreur.
	            Write-output ("ERREUR FATALE : " + $_UsedLine + " " +  $timestamp)  >> $BaseLogErr
	            # Emmission de la log texte vers le Display.
	            Write-Host   ("ERREUR FATALE : " + $_UsedLine + " " +  $timestamp)
	            exit 4
	        }
	    if ( $_UsedLine -ne $null ) 
	        {
	            if ( $_errlevel -eq 0 ) 
	                {
	                    Write-Host  "info  : [ " $_errlevel " ]  Message [ "  $_UsedLine  " ]"
	                    Write-Output $timestamp";Debug;"$_errlevel";"$_UsedLine                          >> $BaseLogFile
	                } 
	                   else 
	                {
	                    if ( $_errlevel -le $DebugLevel ) 
	                        {
	                            Write-Host  "Debug : [ " $_errlevel " ]  Message [ "  $_UsedLine  " ]"
	                           # Write-Output  "$timestamp;Debug;$_errlevel;$_UsedLine"                  >> $BaseLogFile 
	                        }
	                        Write-Output   $timestamp";Debug;"$_errlevel";"$_UsedLine                   >> $BaseLogFile 
	                }
	        }
	            else 
	        { 
	            Write-Output "Attention , votre variable de log est vide"
	        }
	}
	
	function Set-StackMgmF ( [String]$_FunctName, [boolean]$_AddName ) 
	{
	    # Auteur : Arnaud Crampet 19/12/2014
	    # Fonction de génération de stack d'execution des fonctions 
	    # $_FunctName        = Nom de la fontion à ajouter ou à supprimer.
	    # $_AddName          = Variable vrai/faux pour la gestion du mode addition ou soustraction :     $False = Supprime le nom de fonction |   $True Ajoute le nom de la fonction à la trace.
	    # $Global:StackFunct = Variable string à porté globale utilisé par la stack Trace initialisé en debut de script.
	    # Utilisation en ajout       : Set-StackMgmF ($MyInvocation.MyCommand.name) ($True)
	    # Utilisation en suppression : Set-StackMgmF ($MyInvocation.MyCommand.name)  ($False)
	
	    if ( $_AddName -eq $False ) 
	            {
	                # Elimination de la dernière fonction de la stack d'exécution.
	                $Global:StackFunct = $StackFunct.Replace( "\" + $_FunctName, "" ) 
	                $_Uline            = "[ Back To function  : ] " + $StackFunct            # Génération de la ligne de débug.           
	                Write-GlbLogAndMessages ($_Uline) ("4") ($False)                                              # Emission du Debug de base de la fonction. Niveau 4
	            }
	          Else 
	            {
	                # Ajout du nom de la fonction en cour à la stack d'exécution.
	                $Global:StackFunct = $StackFunct + "\" + $_FunctName
	                $_Uline            = "[ Entering function : ] " +  $Global:StackFunct    # Génération de la ligne de débug.                  
	                Write-GlbLogAndMessages ($_Uline) ("4") ($False)                                                # Emission du Debug de base de la fonction. Niveau 4
	      }
	 
	}
	# Fin de des fonction de framwork 
	
	
	
	
	
	
	
	function GenPasswd ([STRING]$_AccountName ) 
	{
	    Set-StackMgmF ($MyInvocation.MyCommand.name)  ($True)
	    #ConvertTo-SecureString [-String] <String
	   
	    
	
	    $__CharsAlpha = @("A","a","B","b","C","c","D","d","E","e","F","f","G","g","H","h","I","i","J","j","K","k","L","l","M","m","N","n","O","o","P","p","Q","q","R","r","S","s","T","t","U","u","V","v","W","w","X","x","Y","y","Z","z")
	    $__CharsNum   = @("1","2","3","4","5","6","7","8","9","0","9","8","7","6","5","4","3","2","1")
	    $__CharsCmp   = @("!",":",";","@","-","#")
	    $__RandRand   = @("1","2","3","2","3","1","3","2","3","1","2","3","1","2","3","1","2","1","1","2","3","2","3","2","1","1","2","3","2","2","1","2","3","2","2","2","3","2","3","2","1","1","2","1","2","3","1","3","2","3","2","1","2","2")
	
	    $__Maxcount = 15
	    $__CurCount = 0
	    $__passwd = ""
	    while($__CurCount -ne $__Maxcount)
	         {
	           $__CurCount++
	           $TypeCharGet = Get-Random -InputObject $__RandRand
	           
	           
	           switch ($TypeCharGet) 
	            { 
	                1 { $__passwdItm = Get-Random -InputObject  $__CharsAlpha  } 
	                2 { $__passwdItm = Get-Random -InputObject  $__CharsNum  } 
	                3 { $__passwdItm = Get-Random -InputObject  $__CharsCmp  } 
	            }
	           $__passwd = $__passwd + $__passwdItm
	           
	           
	         }
	         
	    Write-GlbLogAndMessages ("Generate password for  $_AccountNAme ") ("0") ($False) 
	    Write-GlbLogAndMessages ("  $__passwd") ("0") ($False) 
	    $BaseLogAccnt           = $GLBFolderLogs + "\" + $_AccountName +"_Account_log_"     + $Global:timestampFile + ".txt"      #|#_LogFile   # Log de création des comptes.
	    Write-GlbLogAndMessages ("  Save in file :  $BaseLogAccnt") ("0") ($False) 
	    write-output " Generate password for :  $_AccountNAme " >>   $BaseLogAccnt
	    write-output " password              :  $__passwd "     >>   $BaseLogAccnt
	    
	    Set-StackMgmF ($MyInvocation.MyCommand.name)  ($False)
	   
	}
	
	
	
	function DisplSep ()
	{
	
	Write-GlbLogAndMessages ("") ("0") ($False) 
	Write-GlbLogAndMessages ("----") ("0") ($False) 
	Write-GlbLogAndMessages ("") ("0") ($False) 
	
	}
	
	function Main ()
	{
	    Set-StackMgmF ($MyInvocation.MyCommand.name)  ($True)
	    $name = Read-Host 'What is your username?'
	    GenPasswd ($Name)
	    Set-StackMgmF ($MyInvocation.MyCommand.name)  ($False)
	}
	
	
	main
}
#endregion Source: Gen-Password.ps1

#region Source: ManageCertificates.ps1
function Invoke-ManageCertificates_ps1
{
	#####                                                          ####
	###                                                             ###
	##                                                               ##
	# Author           : Arnaud Crampet                               #
	# Mail             : Arnaud@crampet.net                           #
	# Usage            : Manage selfsigned certificate                #
	# Operating system : Windows 10 or windows server 2016            #
	###################################################################
	
	#Var init
	$CertSubjetCN = 'Dummy'
	$CertLenght   = '1024'
	$Global:CertDuration = '1'
	$CertFqdn     = """www.contoso.com"""
	$cert         = ''
	$CertSavePath = "C:\cert"
	$ClientCertPasswd = ConvertTo-SecureString -String "1234" -Force -AsPlainText
	 
	function Write-Menu-Header 
	{
	 param (
	        [string]$Title = 'My Menu'
	    )
	   Clear-Host
	    Write-Host "================ $Title ================"
	    Write-Host ""
	 }   
	
	function Put-Spacer
	{
	Write-Host ""
	Write-Host "------------------------------------------------"
	Write-Host ""
	}
	
	function EnterToContinue
	{
	 param (
	        [string]$Value = 'Dummy'
	    )
	 
	 Put-Spacer
	 Write-Host "you choose : [ $Value ] "
	 Put-Spacer
	 $dummy = Read-Host -Prompt 'Press enter to continue or CTRL+C to end'
	 Clear-Host
	 }
	
	function Set-KeyLenght
	{
	Write-Menu-Header "Certificate key lenght"
	Put-Spacer
	Write-Host "1 1024 bytes."
	Write-Host "2 2048 bytes."
	Write-Host "3 4096 bytes."
	Write-Host "Q: Press 'Q' to quit."
	Put-Spacer
	$selection = Read-Host "Please make a selection"
	     switch ($selection)
	     {
	         '1' { $Global:CertLenght = '1024'} 
	         '2' { $Global:CertLenght = '2048'}
	         '3' { $Global:CertLenght = '4096'}
	         'Q' { exit 0 }
	     }
	EnterToContinue $Global:CertLenght
	}
	
	function Set-KeyDuration
	{
	Write-Menu-Header "Certificate key duration"
	Put-Spacer
	Write-Host "1  1 months."
	Write-Host "2  3 months."
	Write-Host "3  6 months."
	Write-Host "4 12 months."
	Write-Host "5 24 months."
	Write-Host "6 36 months."
	Write-Host "7 48 months."
	Write-Host "Q: Press 'Q' to quit."
	Put-Spacer
	$selection = Read-Host "Please make a selection"
	     switch ($selection)
	     {
	         '1' { $Global:CertDuration = '1'} 
	         '2' { $Global:CertDuration = '3'}
	         '3' { $Global:CertDuration = '6'}
	         '4' { $Global:CertDuration = '12'} 
	         '5' { $Global:CertDuration = '24'}
	         '6' { $Global:CertDuration = '36'}
	         '7' { $Global:CertDuration = '48'} 
	         'Q' { exit 0 }
	     }
	EnterToContinue $Global:CertDuration
	}
	
	function Set-CertNameCn
	{
	Write-Menu-Header "Certificate Name"
	Put-Spacer
	$global:CertSubjetCN = Read-Host -Prompt 'Input Certificate base CN name'
	EnterToContinue $global:CertSubjetCN
	}
	
	function Set-CertDomaineName
	{
	 Write-Menu-Header "Certificate domaine Name"
	 Put-Spacer
	 Write-Host " You may enter multiple Domaine Name"
	 Write-Host "" 
	 Write-Host " Exemple : ""www.contoso.com"",""www.mydomain.com"",""172.16.1.234"" "
	 Put-Spacer
	 $global:CertFqdn = Read-Host -Prompt 'Input Certificate base full qualified domain name'
	 EnterToContinue $global:CertFqdn 
	}
	
	function Set-CertBaseVar
	{
	 # Globaly used certificate variables
	 Set-CertNameCn
	 Set-KeyLenght
	 Set-KeyDuration
	}
	
	
	function Set-RootCert
	{
	# Create Self signed root certificate
	# -dnsname -DnsName domain.example.com,anothersubdomain.example.com
	# -Subject "CN=Patti Fuller,OU=UserAccounts,DC=corp,DC=contoso,DC=com" 
	Set-CertBaseVar
	New-SelfSignedCertificate -Type Custom -KeySpec Signature `
	-Subject "$Global:CertSubjetCN" `
	-KeyExportPolicy Exportable `
	-HashAlgorithm sha256 -KeyLength $Global:CertLenght `
	-CertStoreLocation "Cert:\CurrentUser\My" `
	-KeyUsageProperty Sign `
	-KeyUsage CertSign `
	-NotAfter (Get-Date).AddYears($Global:CertDuration)
	#wait  = Read-Host -Prompt 'Press enter'
	main
	}
	
	
	function Set-ClientCert
	{
	Set-CertBaseVar
	Get-certificate
	write-host " Generate certificates from root (For Client Authentication only) (Not for web server)"
	$ncert = New-SelfSignedCertificate -Type Custom -KeySpec Signature `
	-Subject "$Global:CertSubjetCN" -KeyExportPolicy Exportable `
	-HashAlgorithm sha256 -KeyLength $Global:CertLenght `
	-NotAfter (Get-Date).AddMonths($Global:CertDuration) `
	-CertStoreLocation "Cert:\CurrentUser\My" `
	-Signer $global:RootCert -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.2")
	EnterToContinue ""
	main
	}
	
	
	function Set-WebServiceCert
	{
	# Generate Web server self signet certificate
	Set-CertBaseVar
	Get-certificate
	Set-CertDomaineName 
	write-host  "Generate certificate from root for web service"
	$ncert = New-SelfSignedCertificate -Type Custom `
	-Subject "$Global:CertSubjetCN" -KeyExportPolicy Exportable `
	-DnsName $Global:CertFqdn `
	-HashAlgorithm sha256 -KeyLength $Global:CertLenght `
	-KeyUsage "KeyEncipherment", "DigitalSignature" `
	-NotAfter (Get-Date).AddMonths($Global:CertDuration) `
	-CertStoreLocation "Cert:\CurrentUser\My" `
	-Signer $global:RootCert
	EnterToContinue ""
	main
	}
	
	function Get-certificate
	{
	$CertList = Get-ChildItem -Path “Cert:\CurrentUser\My” 
	$Counter = 0
	Write-Menu-Header "Certificate Select"
	
	foreach ($cert in $CertList) {
	   Write-Host $Counter " cetificate :" $cert.Subject
	   $counter++
	 }
	 Put-Spacer
	 $ItmVal = Read-Host -Prompt 'Select Certificate base CN name'
	 $global:RootCertTag = $CertList.Item($ItmVal).Subject
	 $global:RootCertThumbprint = $CertList.Item($ItmVal).Thumbprint
	 $global:RootCert =  Get-ChildItem -Path "Cert:\CurrentUser\My\$global:RootCertThumbprint"
	 EnterToContinue $global:RootCertTag
	 
	}
	
	function Get-CertList
	{
	 Write-Menu-Header "Certificate List" 
	 $Certlist = Get-ChildItem -Path “Cert:\CurrentUser\My”
	 $Certlist 
	 write-host "" 
	 write-host " Counted item : " $Certlist.count
	 EnterToContinue  
	 main
	}
	
	
	function Expt-RootCert
	{
	Get-certificate
	If(!(test-path $CertSavePath))
	{
	New-Item -ItemType Directory -Force -Path $CertSavePath
	}
	$FnameBase =  $global:RootCert.Subject.Split("=").Item(1)
	$Fpath1 = $CertSavePath + "\" + $FnameBase + "-Root.cer"
	$Fpath2 = $CertSavePath + "\" + $FnameBase + "x64-Root.cer"
	Export-Certificate -Cert  $global:RootCert -FilePath $Fpath1 
	certutil -encode $Fpath1  $Fpath2
	explorer $CertSavePath
	main
	}
	
	function Exp-ClientCert
	{
	Get-certificate
	If(!(test-path $CertSavePath))
	{
	New-Item -ItemType Directory -Force -Path $CertSavePath
	}
	$FnameBase =  $global:RootCert.Subject.Split("=").Item(1)
	$Fpath1 = $CertSavePath + "\" + $FnameBase + "-client.Pfx"
	 Export-PfxCertificate -Cert  $global:RootCert -FilePath $Fpath1 -Password $ClientCertPasswd
	explorer $CertSavePath
	#main
	}
	
	function Main
	{
	 Write-Menu-Header "Certificate Menu"
	 Put-Spacer
	 Write-Host "1  Create Root Certificate."
	 Write-Host "2  Create Web certificate."
	 Write-Host "3  Create Client authentication certificates."
	 Write-Host "4  export Root authentication certificates (public key only )."
	 Write-Host "5  export Client authentication certificates (public and private key)."
	 Write-Host "L  list all availlable certificates."
	 Write-Host "Q: Press 'Q' to quit."
	 Put-Spacer
	 $selection = Read-Host "Please make a selection"
	     switch ($selection)
	     {
	         '1' { Set-RootCert       } 
	         '2' { Set-WebServiceCert }
	         '3' { Set-ClientCert     }
	         '4' { Expt-RootCert      }
	         '5' {  Exp-ClientCert    }
	         'L' { Get-CertList       }
	         'Q' { exit 0             }
	     }
	}
	
	
	main
}
#endregion Source: ManageCertificates.ps1

#region Source: IIS-SilentInstall.ps1
function Invoke-IIS-SilentInstall_ps1
{
	<#	
		.NOTES
		===========================================================================
		 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.150
		 Created on:   	12/04/2018 14:28
		 Created by:   	Arnaud Crampet
		 Mail TO:		arnaud@crampet.net
		 Organization: 	
		 Filename:     	IIS-SilentInstall.ps1*
		 Opérating System: Windows 2012 server ( datacenter ) R2
		===========================================================================
		.DESCRIPTION
			This script will install IIS ans all needed deps on your server
	#>
	
	
	function Get-Error
	{
	if ($lastExitCode -eq 0 ) { Write-Host " [ OK ] " -ForegroundColor Green}	else { Write-Host " [ ERROR ] " -ForegroundColor Red 
		exit 4}
	}
	
	function Import-IIS-ps
	{
	Write-Host "Getting powershell extention for server managment		" -NoNewline 
	import-module servermanager
	Get-Error
	}
	
	function main
	{
		Import-IIS-ps
		
	}
	
	main
}
#endregion Source: IIS-SilentInstall.ps1

#Start the application
Main ($CommandLine)
